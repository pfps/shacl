= A modest proposal for a refactored SHACL =

This proposal rearranges the SHACL constructs, collapsing constraints and shapes into
one construct.  The result is a more regular SHACL syntax with a simpler metamodel.
A few constructs become a bit more verbose.

This proposal includes some context for the syntax in the preamble section and also
a conformance section to show what SHACL validation engines need to support.

This proposal defines in property paths.  Property paths are complex and do not add
all that much extra expressive power in practice.  (Perhaps the most important is to
be able to count property paths, e.g, at least five grandchildren.)  There is some
wording in the proposal on what removing property paths would involve

This proposal includes a method for removing the need that most shapes include an
explicit rdf:type link to sh:Shape.  It does this by using rdfs:domain and
rdfs:range for various properties, which are given in the metamodel for SHACL, and
then using RDFS typing for the shapes graph.  If all shapes have explicit typing then
there is no need for this kind of mechanism.

The significant changes in this proposal from the current RDF syntax for SHACL are:
# only one SHACL-specific user-instantiatable type in the core - sh:Shape,
# property paths are allowed (but could be removed with little change), 
# the property (path) is separated from the components (constraints), 
# all components (constraints) are given by a single property, and
# the parameters for a component match a shape, and thus can be something like a list.

There are a couple of not-significant changes, which could easily be undone:
# all strings that contain language to be presented to users are rdf:langString, and
# inverse properties are specified via property paths.

This proposal is not quite complete.  Missing bits and questions are shown '''like
this'''.


== Preamble ==

SHACL is designed to determine whether some information satisfies a set of
conditions.  This process is called 'validation' in SHACL.  The main functionality
provided by a SHACL engine is to determine whether one RDF graph, containing the
information to be validated and called the data graph, validates against another RDF
graph, containing the conditions and called the shapes graph because the main
syntactic construct in SHACL is the shape.  Data graphs and nodes in the data graph
are said to validate against shapes.

SHACL is divided into a core portion and an extension portion.  The extension portion
of SHACL uses SPARQL 1.1 Query Language queries in the shapes graph in validation.

This document uses Turtle syntax for graphs and nodes, with the following prefix
bindings:

  rdf:  http://www.w3.org/1999/02/22-rdf-syntax-ns#
  rdfs: http://www.w3.org/2000/01/rdf-schema#
  xsd:  http://www.w3.org/2001/XMLSchema#
  sh:   http://www.w3.org/ns/shacl#

SHACL depends on a notion of instance that uses vocabulary from RDF (rdf:type) and
RDFS (rdfs:subClassOf) but in a way different from both.  A node is a SHACL instance
in the data graph of another node precisely when there is a triple in the data graph
with the instance node as subject, rdf:type as predicate, and object that is either
the other node itself or is linked to that node via a chain of triples in the data
graph with rdfs:subClassOf as predicate.

All SHACL constructs described here are composed only of triples in the shapes graph.

SHACL uses lists in the shapes graph in its syntax.  The list nodes of a node in the
shapes graph are defined as the nodes in transitive-reflexive closure of rdf:rest
triples in the shapes graph considered as a directed relationship between nodes.  A
node in the shapes graph is a SHACL list precisely when
#rdf:nil is in its list nodes,
#all its list nodes have a single rdf:rest, except that rdf:nil has none, and 
#all its list nodes have a single rdf:first, except that rdf:nil has none.
The rdf:first values for the list nodes are the elements of the list, in order.
A list where all the elements have some characteristic is called a list of that
characterstic.

The objects of triples with a given subject and predicate are values of the predicate
for the subject.  That subject is said to have these objects for the predicate.


== Core Syntax ==

The main SHACL construct is a shape.  A shape is a node in the shapes graph that is
an RDFS instance of sh:Shape in the shapes graph.

Shapes in SHACL have
#zero or more scopes (triples with the shape as subject and sh:scopeNode, sh:scopeClass, sh:scopePropertyObject, sh:scopePropertySubject, sh:scopeAllObjects, or sh:scopeAllSubjects as the predicate),
#zero or more filters (triples with sh:filter as the predicate), whose objects are themselves shapes,
#one or more components (triples with the shape as subject and one of the component properties below as property, including associated triples as necessary).

The scopes of a shape select nodes for validation.  Filters further cut down
on the nodes for validation.  Components state conditions that nodes must
satisfy to validate against the shape.

Note:  The shape components might be called constraints.  I didn't use
constraint so as not to cause confusion with the current constraints in SHACL.

The syntax of the various SHACL core components are:  
  PREDICATE       OBJECT
  sh:in           list of nodes
  sh:class        IRI (which is used as a class)
  sh:classIn      list of IRIs (which are used as classes)
  sh:datatype     IRI (which is used as a datatype)
  sh:datatypeIn   list of IRIs (which are used as datatypes)
  sh:directType   IRI (which is used as a class)
  sh:minLength    non-negative integer
  sh:maxLength    non-negative integer
  sh:minExclusive literal
  sh:minInclusive literal
  sh:maxExclusive literal
  sh:maxInclusive literal
  sh:nodeKind     sh:BlankNode or sh:IRI or sh:Literal
  sh:pattern      string used as a regular expression pattern  or
                  two-element list of pattern and string used as flags
  sh:equals       two paths
  sh:notEquals    two paths
  sh:lessThan     two paths
  sh:lessThanOrEqual two paths
  sh:propValues   two-element list of path and shape - replaces sh:property
  sh:list         shape
  sh:shape        shape
  sh:and          list of shapes
  sh:or           list of shapes
  sh:not          shape
  sh:hasValue     node
  sh:minCount     non-negative integer
  sh:maxCount     non-negative integer
  sh:uniqueLang   boolean
  sh:partition    list of shapes
  sh:closed       list of parts (which are used as (inverse) properties)

  sh:constraint	  		shape			for compatability
  sh:property			shape with sh:predicate	for compatability
  sh:inverseProperty		shape with sh:predicate	for compatability
  sh:qualifiedValueShape	shape with qmin or qmax	for compatability

A path is a path part or a list of path parts.  A SHACL core path part is either an
IRI or a node with an sh:inverse link.  Ambiguous constructions are not allowed.

Several other properties of shapes influence SHACL
  sh:severity sh:Info or sh:Warning or sh:Violation
  sh:name language-tagged string
  sh:description language-tagged string
  sh:message language tagged-string
  sh:order decimal literal
  sh:defaultValue node

Note: Qualified cardinalities are replaced by an embedded shape where the embedded
shape's filter has the same role as the value for sh:qualifiedValueShape.

=== Examples ===

  exs:personShape a sh:Shape;
   sh:scopeNode ex:John ;
   sh:scopePropertyObject ex:parent ;
   sh:propValues ( ex:child [ sh:class ex:Person ] ) ;
   sh:propValues ( ex:age [ sh:datatype xs:integer;
   	      	       	    sh:minCount 1 ; sh:maxCount 1 ] ) .

A graph validates against exs:personShape if all SHACL instances of
ex:Person in that graph have all their stated names be strings, all their
stated children belonging to ex:Person, and have exactly one stated age,
which is an integer.

  exs:SJG a sh:Shape;
   sh:scopeClass ex:Person ;
   sh:filter [ sh:propValues ( ex:gender [ sh:hasValue ex:female ] ) ] ;
   sh:filter [ sh:propValues ( ( ex:child ex:child ) [ sh:minCount 5 ] ) ] ;
   sh:propValues ( ex:child 
     [ sh:filter [ sh:propValues ( ex:gender [ sh:hasValue ex:male ] ) ] ;
       sh:class ex:Professional ] ) .

A graph validates against exs:SJG if all SHACL instances of ex:Person (the scope)
that have ex:female as gender (the first filter) and have at least five grandchildren
(the second filter) have all their male children be SHACL instances of
ex:Professional.

  ex:IssueShape a sh:Shape ;
    sh:scopeClass ex:Issue;
    sh:propValues ( ex:state [ sh:in (ex:unassigned ex:assigned) ;
    		    	       sh:minCount 1 ; sh:maxCount 1 ; ] ) ;
    sh:propValues ( ex:reportedBy [ sh:shape ex:UserShape ;
    		    		    sh:minCount 1 ; sh:maxCount 1 ; ] ) .
  ex:UserShape a sh:Shape ;
    sh:propValues ( foaf:name [ sh:datatype xsd:string ;
    		    	      	sh:minCount 1 ; sh:maxCount 1 ; ] ) ;
    sh:propValues ( foaf:mbox [ sh:nodeKind sh:IRI ;
    		    	      	sh:minCount 1 ; ] ) .

Example 1 from SHACL document

  exs:sample a sh:Shape ;
   sh:scopeNode ex:John ;
   sh:scopePropertyObject ex:parent ;
   sh:propValues ( ex:dependent [ sh:class ex:Person ;
   		   		  sh:class ex:Child ;
			      	  sh:shape ex:sample2 ] ) ;
   sh:propValues ( ex:age [ sh:datatype xs:integer ;
   		   	    sh:minCount 1 ; sh:maxCount 1 ;
   		   	    sh:minInclusive 12 ] ) ;
  exs:sample2 a sh:Shape ;
   sh:propValues ( ex:age [ sh:datatype xs:integer ;
   		   	    sh:minCount 1 ; sh:maxCount 1 ;
   		   	    sh:minInclusive 25 ] ) .

Just showing some other syntax.


== Validation results ==

'''TO BE DONE, but no significant changes, if any'''



== Informal Semantics for Core (no recursion) ==

A data graph validates against a shapes graph if the data graph validates
against every shape in the shapes graph that has at least one scope.
A data graph validates against a shape if the set of nodes of the graph
selected by any scope of the shape validate against the shape.

A sh:scopeNode value selects that node.
A sh:scopeClass value selects each node that is a SHACL instance of the
class in the data graph. 
A sh:scopePropertyObject value selects each node that is the object of some 
triple with that property as predicate in the data graph.
A sh:scopePropertySubject value selects each node that is the subject of a
triple with that property as predicate in the data graph. 
A sh:scopeAllObjects selects all nodes that are objects of some triple in
the data graph.
A sh:scopeAllSubjects selects all nodes that are subjects of some triple in
the data graph.

A set of nodes (the input nodes) validates against a shape as follows.
In-focus nodes are those input nodes which validate against each of the
filters.  Input nodes that are not in-filter nodes are called out-of-filter
nodes.

Some components (sh:shape, sh:and, sh:or, sh:not, sh:hasValue, sh:minCount,
sh:maxCount, sh:uniqueLang, and sh:partition) work on the set of in-filter
nodes considered as a whole.  There is one or more elements in the
validation result precisely when one or more in-filter node fails to
validate against the component.  The component separately determines which
in-filter nodes validate or fail to validate against the component.

The other components (sh:in, ..., sh:pattern, sh:propValues) work on each
in-filter node independently.  The validation results for the component
contains an element for each in-filter node that failed to validate against
that component.  In-filter nodes for which there is no validation result are
considered to validate against the component.

A set of input nodes validates against a shape if all in-filter nodes
validate against each of the shape's components.

The non-template components work as follows, where all typing determinations
are made in the data graph, all triples come from the data graph, and paths
are processed similar to path processing in the SPARQL 1.1 Query Language.

* sh:in list of node
:: Each in-focus node is in the list.
* sh:class class
:: Each in-focus node has class as one of its SHACL types.
* sh:classIn ( class ... )
:: Each in-focus node has one of the classes as one of its SHACL types.
* sh:datatype datatype
:: Each in-focus node has datatype as its datatype.
* sh:datatypeIn ( datatypes ... )
:: Each in-focus node has one of the datatypes as its datatype.
* sh:directType class
:: Each in-focus node has an rdf:type link to the class.
* sh:minLength non-negative integer
:: The SPARQL str representation of each in-focus node is at least this long.
* sh:maxLength non-negative integer
:: The SPARQL str representation of each in-focus node is at most this long.
* sh:minExclusive literal
:: Each in-focus node is greater than this literal.
* sh:minInclusive literal
:: Each in-focus node is greater than or equal to this literal.
* sh:maxExclusive literal
:: Each in-focus node is less than this literal.
* sh:maxInclusive literal
:: Each in-focus node is less than or equal to this literal.
* sh:nodeKind sh:BlankNode or sh:IRI or sh:Literal
:: Each in-focus node is a blank node, an IRI, a literal, respectively.
* sh:pattern pattern or  ( pattern flags )
:: The SPARQL str representation each in-focus node matches pattern, using flags if present.
* sh:equals ( path1 path2 )
:: Each in-focus node has the same values for each path starting at the node.
* sh:notEquals ( path1 path2 )
:: Each in-focus node has different sets of values for each path starting at the node.
* sh:lessThan ( path1 path2 )
:: For each in-focus node each value for a path is < each value for the next path.
* sh:lessThanOrEqual ( path1 path2 )
:: For each in-focus node each value for a path is <= each value for the next path.
* sh:propValues ( path shape ) 
:: For each in-focus node the values of path validate against shape.
* sh:list shape
:: Each in-focus node is a SHACL list and its list elements validate against shape.
* sh:closed ( property ... )
:: Each in-focus node has no values for any property not in the list or that is not the property of a sh:propValues component of the shape.
  
* sh:shape shape
:: The nodes that validate are those that validate against the shape.
* sh:and ( shape ... shape )
:: The nodes that validate are those that validate against each shape.
* sh:or ( shape ... shape )
:: The nodes that validate are those that validate against some shape.
* sh:not shape
:: The nodes that validate are those that fail to validate against the shape.
* sh:hasValue node
:: Some in-focus node is the same as the node.
* sh:minCount int
:: There are at least int in-filter nodes.
* sh:maxCount int
:: There are at most int in-filter nodes.
* sh:uniqueLang true
:: An in-focus node fails to validate if it has the same language tag as another.
* sh:partition ( shape_1, ..., shape_n )
:: Let input_1 be the set of in-filter nodes.
:: Let input_i+1 be the out-of-filter nodes of shape_i for input_i.
:: Nodes that fail to validate for shape_i on input_i fail for the component, for 1<=i<=n.
:: Nodes in input_n+1 fail to validate for the component.


== SPARQL Extension Mechanism (REVISED) ==

This is a description of the syntax of a SPARQL extension for SHACL based on
substitution and an account of how it works.  This extension mechanism for
SHACL does not depend on any extensions to SPARQL and thus can be used with
any SPARQL implementation or service, including SPAQL endpoints

=== Using SPARQL Queries in SHACL ===

The extension uses solutions in SPARQL result sets as validation results.
These solutions have bindings for at least ?this and ?severity.  A set of
nodes validates against a component in the SPARQL extension if evaluating
the SPARQL query for the component over the data graph would produce no
query results with ?severity bound to sh:Violation when joined to a result
set with solutions having ?this bound to elements of the set.  Validation
fails on nodes that have a solution in the joined result set with ?this
bound to the node and ?severity bound to sh:Violation.

The extension uses solutions in SPARQL result sets as scopes and as
synthetic properties.  For scopes, the set of nodes in a scope are the set
of bindings for ?scope in the solutions of a result set.  For synthetic
properties, the set of subject, object pairs in a synthetic property are the
set of pairs of bindings for ?subject and ?object in the solutions of a
result set.

The SPARQL queries in this extension are always augmented with namespace
prefix bindings for rdf:, rdfs:, xsd:, and sh: as above.  '''A mechanism for
augmenting these bindings might be useful.'''

The SPARQL queries in this extension are always run over the data graph.
(The shapes in templates validate arguments to components and scopes, so the
data graph for them is the shapes graph.)

=== Component Templates ===

Component templates provide components based on parameterized SPARQL code.  A
component template is a node in the shapes graph that is an RDFS instance of
sh:ComponentTemplate in the shapes graph.  Each triple in the shapes graph
whose subject is a shape and whose property is a component template is a
template component of the shape.

A component template is used as a shape to check the syntactic validity of
template components.  The object of a template component triple is validated
against the component template considered as a shape.  If the validation
fails the template component is syntactically illegal.  The sh:propValues
components in component templates can also have sh:argumentName and
sh:argumentDefault triples that are used in the process of constructing the
query for template components.

Component templates provide SPARQL queries to define the query via 
  sh:templateQuery   parameterized SPARQL query

Alternatively the query can be constructed from other properties
  sh:templateFilter  parameterized SPARQL expression
  sh:templatePattern parameterized SPARQL pattern
  sh:templateHaving  parameterized SPARQL expression
  sh:templateMessage parameterized language-tagged string
The sh:templateFilter evaluates to true for ?this bindings that would
validate against the component.  The sh:templatePattern eliminates bindings
for ?this that would validate against the component.  The sh:templateHaving
eliminates groups of solutions for ?this bindings that would validate
against the component.  The values for sh:templateMessage are used to
construct the message part of validation results.  They are all used to
construct a parameterized query for the component that looks like
  SELECT [projection] ?this ?message ?severity (?this AS ?object)
  WHERE { [outer] [inner] <pattern> FILTER ( ! <filter> ) }
  [group] HAVING <having>
  VALUES (?message ?severity) { ( <message> [severity] ) }
where the FILTER ( ! <filter> ) part is only present if there is a value for
sh:templateFilter and the [group] HAVING <having> part is only present if
there is a value forsh:templateHaving.

The actual query for the template component is produced by substitution into
the parameterized query. Values for all five of the above properties can
have substrings of the form 
  [expression]
that are treated as substitution expressions subject to replacement.
Substition expressions can be 
# a quoted string
# a simple name, where the name's value in the context is substituted
# p(name), where the name's value is processed as a path
# s(name), where the name's value is processed as a shape
# c(path name), where the name's value is processed as a shape to produce a shape for path values
# l(expression string), where the list values for the value of identifier in expression are processed instead of its values and the results joined with string
All processing happens in the shapes graph.

The values for names are set up from two sources.  Values for several
standard names are set up automatically:
# argument is the object of the template component triple
# projection is usually a SPARQL variable that serves as a context 
# outer is usually a SPARQL pattern that produces bindings for the projection variable
# inner is a SPARQL pattern that produces bindings for ?this
# group is usually a SPARQL GROUP BY fragment that groups by the projection variable
# severity is the severity to be used in the component

Other values come from sh:propValues components in the component template that
have sh:argumentName triples in their shape.  Each such sh:propValues
component produces a value for the object of its sh:argumentName triple that
is either one of the values for its path starting from the its argument or
the value of its sh:argumentDefault triple if there are no value for the path.

'''Note: Having multiple sh:propValues with the same sh:argumentName leads
to indeterminate results.'''

'''Note: Having multiple values for an argument path leads to indeterminate
results.'''

=== Scope Templates ===

Scope templates provide scopes based on parameterized SPARQL queries.  A
scope template is a node in the shapes graph that is an RDFS instance of
sh:ScopeTemplate in the shapes graph.  Each triple in the shapes graph whose
subject is a shape and whose property is a scop template is a template scope
of the shape.  A scope template is also used as a shape in the same way that
a component template is.

Scope templates provide SPARQL queries to define the query via 
  sh:templateQuery parameterized SPARQL query
The query for a template scope is constructed in the same way as for a
template component except that the alternative query consruction method is
not used.  As well, the only standard name is argument.
o
The nodes in the scope are the bindings for ?scope in solutions in the
result set of the query augmented as above run over the data graph.

=== Direct Use of SPARQL Queries ===

SPARQL queries are directly allowed in shape components via
  sh:query SPARQL query
The SPARQL query for a sh:sparql component is the provided query with no
substitutions. 

SPARQL queries are directly allowed in scopes via
  sh:scopeQuery SPARQL query
The SPARQL query for a sh:scopeQuery scope is produced with no substitution.

'''UNDER REVIEW'''
SPARQL queries are also allowed as path parts.  The bindings of ?subject and
?object in solutions of its result set are considered as subjects and
objects of a synthetic property.  '''This produces truly awful syntax, and
should be fixed.'''  Note: The derived values equality constraint is
replaced by an sh:equals with one of the paths using SPARQL code.

=== Examples ===

  ex:example a sh:ComponentTemplate ;
    sh:propValues ( ex:predicate [ sh:class rdf:Property;
    	       		      sh:minCount 1 ; sh:maxCount 1 ] ) ;
    sh:propValues ( ex:lang [ sh:datatype xs:string ] ) ;
    sh:sparqlTemplate """... ?this ...""" .

  ex:exampleShape a sh:Shape ;
    ex:example [ ex:predicate ex:p ; ex:lang "de" ; ex:lang "en" ] .

  sh:class a sh:ComponentTemplate ; rdfs:domain sh:Shape ; rdfs:range rdfs:Class ;
    sh:nodeKind sh:IRI ;
    sh:templateMessage "Does not have required class [argument]" ;
    sh:messsage "Classes need to be IRIs" ;
    sh:templateFilter "EXISTS { ?this rdf:type/rdfs:subClassOf* [argument] }" .

  ex:listexShape a sh:Shape ;
     ex:listex ( ex:person ex:p2 ) .


== Conformance ==

A SHACL validation engine MUST provide an interface that validates a data graph
against a shapes graph containing only core SHACL constructs, as described herein,
and returns all the validation results for each shape in the shapes graph.  A SHACL
validation engine MAY provide interfaces that return only some of the validation
results.  These interfaces MUST also return a boolean result that is true only if
this set is the entire set of validation results.  A SHACL validation engine MAY
provide an interface that returns true if there is at least one validation result
with severity sh:Violation, false otherwise.

A SHACL validation engine MAY provide interfaces that construct the shapes graph and
data graph from other inputs and perform validation on these constructed graphs.  If
so, the engine must provide an interface that takes an RDF dataset and optionally the
IRI of a graph in that dataset.  The engine constructs the data graph starting with
the graph with that name, or the default graph of the dataset if not provided with a
graph name, and incorporating other graphs from the datatset using owl:imports.  The
engine constructs the shapes graph by starting with all graphs in the dataset with
names taken from objects of sh:shapesGraph triples in the data graph and then using
owl:imports.  '''MORE PRECISE?'''

A SHACL validation engine MUST implement all the core constructs of SHACL.  If a
SHACL validation engine implements any of the extended constructs of SHACL then it
MUST implement them all.

A SHACL validation engine MAY produce warnings if nodes that are expected to be in
the data graph are not present there (e.g., for sh:scopeNode) or are not a SHACL
instance there of an expected type (e.g., sc:scopeClass values and rdfs:Class).

A SHACL validation engine MUST provide an interface that signals an error if the
shapes graph contains SHACL instances of sh:Shape that do not conform to the syntax
herein or that have themselves as a shape in the transitive closure of their core
components and filters.  '''MORE PRECISE?''' If the SHACL validation engine
implements any of the extended constructs of SHACL then this MUST also consider
template components.
